<script lang="ts">
import Vue from 'vue';
import { Component, Prop } from 'vue-property-decorator';

import { bloxLink, bloxQty } from '@/helpers/bloxfield';
import { createDialog } from '@/helpers/dialog';
import { digitalConstraintLabels } from '@/plugins/spark/getters';
import { sparkStore } from '@/plugins/spark/store';
import { BlockType, MutexBlock, Quantity } from '@/plugins/spark/types';
import type {
  DigitalConstraint,
  DigitalConstraintKey,
  DigitalConstraintsObj,
  MutexedConstraint,
} from '@/plugins/spark/types';

interface Wrapped {
  type: DigitalConstraintKey;
  constraint: DigitalConstraint;
}

@Component
export default class DigitalConstraints extends Vue {
  @Prop({ type: Object, default: () => ({ constraints: [] }) })
  protected readonly value!: DigitalConstraintsObj;

  @Prop({ type: String, required: true })
  public readonly serviceId!: string;

  get constraints(): Wrapped[] {
    return this.value.constraints
      .map(constraint => {
        const type = Object.keys(constraint).find(k => k != 'remaining') as DigitalConstraintKey;
        return { type, constraint };
      });
  }

  save(constraints: Wrapped[] = this.constraints): void {
    this.$emit('input', { constraints: constraints.map(c => c.constraint) });
  }

  get constraintOpts(): SelectOption[] {
    return Object.entries(digitalConstraintLabels)
      .map(([k, v]) => ({ value: k, label: v }));
  }

  createDefault(type: DigitalConstraintKey): Wrapped {
    const opts: Record<DigitalConstraintKey, DigitalConstraint> = {
      minOff: {
        remaining: bloxQty('0s'),
        minOff: bloxQty('0s'),
      },
      minOn: {
        remaining: bloxQty('0s'),
        minOn: bloxQty('0s'),
      },
      delayedOff: {
        remaining: bloxQty('0s'),
        delayedOff: bloxQty('0s'),
      },
      delayedOn: {
        remaining: bloxQty('0s'),
        delayedOn: bloxQty('0s'),
      },
      mutexed: {
        remaining: bloxQty('0s'),
        mutexed: {
          mutexId: bloxLink(null, BlockType.Mutex),
          hasCustomHoldTime: false,
          extraHoldTime: bloxQty('0s'),
          hasLock: false,
        },
      },
    };
    return { type, constraint: opts[type] };
  }

  isCustom(constraint: MutexedConstraint): boolean {
    return constraint.mutexed.hasCustomHoldTime;
  }

  holdTime(constraint: MutexedConstraint): Quantity {
    if (this.isCustom(constraint)) {
      return constraint.mutexed.extraHoldTime;
    }
    else if (constraint.mutexed.mutexId.id) {
      const mutex = sparkStore.blockById<MutexBlock>(
        this.serviceId,
        constraint.mutexed.mutexId.id);
      return mutex?.data.differentActuatorWait ?? bloxQty('0s');
    }
    else {
      return bloxQty('0s');
    }
  }

  add(): void {
    createDialog({
      component: 'CheckboxDialog',
      title: 'Add constraint',
      selectOptions: this.constraintOpts,
    })
      .onOk(keys => {
        this.constraints.push(...keys.map(this.createDefault));
        this.save();
      });
  }

  remove(idx: number): void {
    this.$delete(this.constraints, idx);
    this.save();
  }
}
</script>

<template>
  <div class="column q-gutter-y-xs">
    <div
      v-for="({type, constraint}, idx) in constraints"
      :key="idx"
      :class="[
        'row q-gutter-x-sm q-gutter-y-xs constraint',
        { limiting: constraint.remaining.value }
      ]"
    >
      <template v-if="type === 'mutexed'">
        <LinkField
          :service-id="serviceId"
          :value="constraint.mutexed.mutexId"
          title="Mutex"
          label="Mutex"
          class="col-grow"
          @input="v => { constraint.mutexed.mutexId = v; save(); }"
        />
        <DurationField
          :value="holdTime(constraint)"
          title="Extra lock time"
          label="Extra lock time"
          message="The Mutex will be kept locked for this duration after the actuator turns off."
          class="col-grow"
          :tooltip="
            isCustom(constraint)
              ? null
              : 'Using default value from Mutex block.'
          "
          @input="v => {
            constraint.mutexed.extraHoldTime = v;
            constraint.mutexed.hasCustomHoldTime = true;
            save();
          }"
        >
          <template #append>
            <template v-if="isCustom(constraint)">
              <q-btn
                flat
                round
                icon="mdi-backup-restore"
                size="sm"
                @click.stop="constraint.mutexed.hasCustomHoldTime = false; save()"
              >
                <q-tooltip>Use default value from Mutex block.</q-tooltip>
              </q-btn>
            </template>
          </template>
        </DurationField>
      </template>
      <DurationField
        v-if="type === 'minOff'"
        :value="constraint.minOff"
        title="Minimum OFF period"
        label="Minimum OFF period"
        class="col-grow"
        @input="v => { constraint.minOff = v; save(); }"
      />
      <DurationField
        v-if="type === 'minOn'"
        :value="constraint.minOn"
        title="Minimum ON period"
        label="Minimum ON period"
        class="col-grow"
        @input="v => { constraint.minOn = v; save(); }"
      />
      <DurationField
        v-if="type === 'delayedOff'"
        :value="constraint.delayedOff"
        title="Delay OFF"
        label="Delay OFF"
        class="col-grow"
        @input="v => { constraint.delayedOff = v; save(); }"
      />
      <DurationField
        v-if="type === 'delayedOn'"
        :value="constraint.delayedOn"
        title="Delay ON"
        label="Delay ON"
        class="col-grow"
        @input="v => { constraint.delayedOn = v; save(); }"
      />

      <div class="col-auto column justify-center darkish">
        <q-btn icon="delete" flat round @click="remove(idx)">
          <q-tooltip>Remove constraint</q-tooltip>
        </q-btn>
      </div>
    </div>
    <div class="col row justify-end">
      <q-btn icon="add" round outline @click="add">
        <q-tooltip>Add constraint</q-tooltip>
      </q-btn>
    </div>
  </div>
</template>

<style lang="sass" scoped>
.limiting
  text-color: orange

.constraint:nth-child(even) > label
  background: rgba($green-5, 0.05)

.constraint:nth-child(odd) > label
  background: rgba($blue-5, 0.05)
</style>
